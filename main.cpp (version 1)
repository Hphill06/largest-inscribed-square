// version 2 
/*
this version was uploaded on 2/5/25
this version is a stepping stone inbetween the last one and having a function that fills in the gaps between points
todo:

1) no find square function: this function will be implemented within the next commit

2) points between points: currently the shape on the screen is not the same as the exact input the user uses, this is because if I just drew a pixel on the exact
pixel the user draws it would skip around a bunch and have gaps everywhere, to handle this I have made it draw lines between the points but these new points in between
are not inside the points array and would not be considered by the program as points that could be used for a square and in order to find the largest one they need to be.

^ive found a way to solve this just need to implement it into my program but ive been swamped with other classes lately lol i will incriment the slope along 
a line between two points and at each point add it to the array of total points 


3) (maybe) After adding the features above if the program runs slow I plan to shrink the possible drawing area in order to make time to run quicker, 
or find a way to better optimize the functions I already have

*/

#include <iostream>
#include "graph1.h"
#include <vector>
#include <random>
using namespace std;
struct point {
	int x;
	int y;
};
struct square {
	vector<point> points; // vector of 4 points that is a rectangle
};


void drawPoints(vector<point> vectorOfPoints, int size);
void drawInstructionText(int size);
bool canPointBeUsed(int x, int y);
square findRandomSquare(vector<point> pointlist);
float DistanceBetweenTwoPoints(point point1, point point2);
vector <point> addPoint(vector<point> pointList,int mouse_x, int mouse_y); // added this function to break it out of the main function since it will get complecated 
float slopeOfLine(point point1,point point2);

int main() {
	displayGraphics();
	srand(time(0));
	// var decleration
	int mouse_X, mouse_Y,points_Array_Size= 0;
	vector<point> points;
	bool has_mouse_Dragged = false;

	drawInstructionText(points_Array_Size);	// draws the inscructions on the top of the screen for the first time, after this its only drawn when the screen is updated

	while (true) {
		points_Array_Size = points.size(); // called at the top of the loop once instead of every single time i need this info

		if (mouseDragged(mouse_X, mouse_Y)) { //only runs if mouseDragged retruns true, and the mouse x and y values are changed by being passed by refrence 
			if (canPointBeUsed(mouse_X, mouse_Y)) { // this if statement fixes a weird error with graph1.h that likes to throw in a -1,-1 input before everything when starting the program
				has_mouse_Dragged = true; // lets the program know it needs to update the screen
				points = addPoint(points, mouse_X, mouse_Y);
				
			}
			
		}
		//input handling
		
		if (up()) { // reset input
			points.clear(); // clears the vector of past points
			clearGraphics(); // clears the screen
			drawInstructionText(0); // reprints the text at the top of the screen so its not just a blank screen

		}
		if (down()) {// outputs a random square on the shape
			square square = findRandomSquare(points);
		}
		
		if (has_mouse_Dragged) { // if updated
			clearGraphics(); // clears the graphics so the new updated version can be drawn
			drawPoints(points, points_Array_Size); // draws the shape onto screen by taking the points given by the users mouse dragging and connecting them via lines
			drawInstructionText(points_Array_Size);// reprints the text at the top of the screen so its not just a blank screen
			has_mouse_Dragged = false; // resets so that if the user stops putting in any input, it doesnt redraw the screen over and over
		}
	}
	return 0;
}

void drawPoints(vector<point> vectorOfPoints, int size) // only called if the mouse is currently being dragged;
{
	
	
	for (int i = 0; i < size; i++) { // links every point from 0 to size via a line with a width of 3
		drawLine(vectorOfPoints[i].x, vectorOfPoints[i].y, vectorOfPoints[i + 1].x, vectorOfPoints[i + 1].y, 3);
		setColor(drawPoint(vectorOfPoints[i].x, vectorOfPoints[i].y), 255, 0, 0);// this part draws red dots over the top of the white line so i can see where the real points are in the vector
	}
	drawLine(vectorOfPoints[0].x, vectorOfPoints[0].y, vectorOfPoints[size].x, vectorOfPoints[size].y, 3); // connects the first and last point together to make a closed shape
	
	
}

void drawInstructionText(int size)
{
	gout << setPos(10, 10) << "drag your mouse to draw a shape, press up on the keyboard to reset points" << endg;
	gout << setPos(10, 25) << "then press right on the keyboard to find the biggest square that can be formed from the points" << endg;
	gout << setPos(10, 40) << "sizeOfArray : " << size << endg;
}

bool canPointBeUsed(int x, int y)
{
	if (x < 0 || y < 0) {// if the x or y values are negative do not use them
		return false;
	}
	return true;
}

square findRandomSquare(vector<point> pointlist) // todo
{
	for (int i = 0; i < pointlist.size(); i++) {
		int randPoint = rand() % pointlist.size();
		float distance = DistanceBetweenTwoPoints(pointlist[i], pointlist[randPoint]);
		float slope = slopeOfLine(pointlist[i], pointlist[randPoint]);
		//cout << "point number #" << i + 1 << " is " << distance << " away from point number #" << randPoint;
		//cout << "   point number #" << i + 1 << "( " << pointlist[i].x << " , " << pointlist[i].y << " )  " << endl;
		
		cout <<"slope: " << slopeOfLine(pointlist[i], pointlist[randPoint]) << endl;
	}
	return square();
}

float DistanceBetweenTwoPoints(point point1, point point2)
{
	return sqrt(pow(point2.x-point1.x,2) + pow(point2.y-point1.y,2));
}

vector<point> addPoint(vector<point> pointList, int mouse_x, int mouse_y)
{
	// gets points inbetween the two points // to do
	/*
	to do this i will get the slope between each point, then incriment that slope onto a point and then do that until its met the other point 
	and add each incrimented point to the points array
	*/

	pointList.push_back(point{ mouse_x,mouse_y });
	return pointList;
}

float slopeOfLine(point point1, point point2)
{
	float bottom = (point2.x - point1.x);
	float top = (point2.y - point1.y);
	if (bottom == 0) { return 0; }; // solves divide by zero error
	return top/bottom;
}

